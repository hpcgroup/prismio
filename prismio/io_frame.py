# Copyright 2020-2021 Parallel Software and Systems Group, University of
# Maryland. See the top-level LICENSE file for details.
#
# SPDX-License-Identifier: MIT

"""
The prismio.io_frame module provides the IOFrame class for structured data
structure and flexible api of tracing/profiling data generated by Recorder
or Darshan
"""


import sys
import os
import numpy as np
import pandas as pd
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt
# import tkinter

class IOFrame:
    """
    Main class of the prism application. It holds I/O performance data 
    generated by I/O tools. It reorganizes the data into a Pandas.DataFrame,
    which contains useful information such as the start time of functions, 
    the files functions access to, etc. It also provides flexible api 
    functions for user to do analysis.
    """
    def __init__(self, dataframe):
        """
        Args:
            dataframe (DataFrame): the dataframe this IOFrame should have.

        Return:
            None.

        """
        self.dataframe = dataframe

    @staticmethod
    def from_recorder(log_dir):
        """
        Read trace files from recorder and create the corresponding
        IOFrame object.

        Args:
            log_dir (str): path to the trace files directory of Recorder the user wants to analyze.

        Return:
            A IOFrame object corresponding to this trace files directory.

        """
        from prismio.readers.recorder_reader import RecorderReader
        return RecorderReader(log_dir).read()

    def filter(self, my_lambda): 
        """
        Create a new IOFrame based on the filter function the user provides.

        Args:
            my_lambda (function): filtering function. For example, np.sum, np.sort.

        Return:
            A new IOFrame object with a new filtered dataframe.

        """
        dataframe = self.dataframe[self.dataframe.apply(my_lambda, axis = 1)]
        dataframe = dataframe.reset_index()
        dataframe = dataframe.drop('index', axis=1)
        return IOFrame(dataframe)

    def groupby_aggregate(self, groupby_columns, agg_function):
        """
        Return a dataframe after groupby and aggregate operations on the dataframe of this IOFrame.

        Args:
            groupby_columns (list of strings): the column names the user want to groupby.
            agg_function (function or string): the function used for aggregation. For example, 'sum', 'count', etc.

        Return:
            A dataframe after groupby and aggregate operations on the dataframe of this IOFrame.

        """
        groupby_obj = self.dataframe.groupby(groupby_columns)
        agg_dataframe = groupby_obj.agg(agg_function)
        return agg_dataframe
    
    def file_count(self, rank=None, agg_function=np.mean):
        file_count = self.groupby_aggregate(['rank'], 'nunique')['file']
        if rank != None:
            file_count = file_count.filter(items=rank)
        if agg_function == None:
            return file_count.to_dict()
        else:
            return agg_function(file_count.to_list())

    def file_access_count(self, rank=None, agg_function=np.mean):
        groupby_obj = self.dataframe.groupby(['file'])
        file_access_count = {}
        for key, group in groupby_obj:
            file_access_count_per_rank = group.groupby(['rank'])['fid'].count()
            if rank != None:
                file_access_count_per_rank = file_access_count_per_rank.filter(items=rank)
            file_access_count[key] = file_access_count_per_rank
        file_access_count = pd.DataFrame(file_access_count)
        if agg_function == None:
            return file_access_count
        else:
            return file_access_count.apply(agg_function)
            
    def function_count(self, rank=None, agg_function=np.mean):
        groupby_obj = self.dataframe.groupby(['function'])
        function_count = {}
        for key, group in groupby_obj:
            function_count_per_rank = group.groupby(['rank'])['fid'].count()
            if rank != None:
                function_count_per_rank = function_count_per_rank.filter(items=rank)
            function_count[key] = function_count_per_rank
        function_count = pd.DataFrame(function_count)
        if agg_function == None:
            return function_count
        else:
            return function_count.apply(agg_function)

    def function_time(self, rank=None, agg_function=np.mean):
        groupby_obj = self.dataframe.groupby(['function'])
        function_time = {}
        for key, group in groupby_obj:
            function_time_per_rank = group.groupby(['rank'])['time'].sum()
            if rank != None:
                function_time_per_rank = function_time_per_rank.filter(items=rank)
            function_time[key] = function_time_per_rank
        function_time = pd.DataFrame(function_time)
        if agg_function == None:
            return function_time
        else:
            return function_time.apply(agg_function)

    def function_calls_by_library(self, rank=None, agg_function=np.mean):
        
        def check_library(function):
            if 'H5' in function:
                return 'hdf5'
            elif 'MPI' in function:
                return 'mpi'
            else:
                return 'posix'

        self.dataframe['layer'] = self.dataframe['function'].apply(lambda function: check_library(function))
        groupby_obj = self.dataframe.groupby(['layer'])

        function_calls_by_library = {}
        for key, group in groupby_obj:
            function_calls_by_library_per_rank = group.groupby(['rank'])['function'].count()
            if rank != None:
                function_calls_by_library_per_rank = function_calls_by_library_per_rank.filter(items=rank)
            function_calls_by_library[key] = function_calls_by_library_per_rank
        function_calls_by_library = pd.DataFrame(function_calls_by_library)
        if agg_function == None:
            return function_calls_by_library
        else:
            return function_calls_by_library.apply(agg_function)

    def print_trace(self, functions=None):
        dataframe = self.dataframe
        if functions != None:
            dataframe = dataframe[dataframe['function'].isin(functions)]
        groupby_obj = dataframe.groupby(['function'])
        for key, group in groupby_obj:
            x = [np.NaN] * 3 * len(group)
            x[::3] = group['tstart']
            x[1::3] = group['tend']
            y = [np.NaN] * 3 * len(group)
            y[::3] = group['rank']
            y[1::3] = group['rank']
            plt.plot(x, y, label=key)
        plt.show()
        plt.clf()

    def print_io_sizes(self):
        io_sizes = self.groupby_aggregate(['io_size'], 'count')['function']
        ax = io_sizes.plot.bar()
        Y = io_sizes.values
        for i, y in enumerate(Y):
            ax.text(i, y + 1, y, ha='center', va='bottom')
        plt.savefig("mygraph.png")
